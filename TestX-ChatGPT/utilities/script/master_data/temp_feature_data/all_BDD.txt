Cucumber Reference
Cucumber can be used to implement automated tests based on scenarios described in your Gherkin feature files.

Step Arguments
In the example given in step definitions, Cucumber extracts the text 48 from the step, converts it to an int and passes it as an argument to the method.

The number of parameters in the method has to match the number of capture group s in the expression. (If there is a mismatch, Cucumber will throw an error).

Data Tables
Data tables from Gherkin can be accessed by using the DataTable object as the last parameter in a step definition. This conversion can be done either by Cucumber or manually.

Depending on the table shape as one of the following collections:
List<List<String>> table
List<Map<String, String>> table
Map<String, String> table
Map<String, List<String>> table
Map<String, Map<String, String>> table
The simplest way to pass a List<String> to a step definition is to use a data table:

Given the following animals:
  | cow   |
  | horse |
  | sheep |
Declare the argument as a List<String>, but don’t define any capture group s in the expression:

Annotated method style:

@Given("the following animals:")
public void the_following_animals(List<String> animals) {
}
In this case, the DataTable is automatically flattened to a List<String> by Cucumber (using DataTable.asList(String.class)) before invoking the step definition.

Note: In addition to collections of String, Integer, Float, BigInteger and BigDecimal, Byte, Short, Long and Double are also supported.

In addition, see cucumber-jvm data-tables

Steps
A step is analogous to a method call or function invocation.

For example:

Given I have 93 cucumbers in my belly
In this step, you’re “calling” the above step definition with one argument: the value 93.

Steps are declared in your *.feature files.

Matching steps
Cucumber matches a step against a step definition’s Regexp
Cucumber gathers any capture group s or variables
Cucumber passes them to the step definition’s method and executes it
Recall that step definitions start with a preposition or an adverb (Given, When, Then, And, But).

All step definitions are loaded (and defined) before Cucumber starts to execute the plain text in the feature file.

Once execution begins, for each step, Cucumber will look for a registered step definition with a matching Regexp. If it finds one, it will execute it, passing all capture group s and variables from the Regexp as arguments to the method.

The specific preposition/adverb used has no significance when Cucumber is registering or looking up step definitions.

Also, check out multiline step arguments for more info on how to pass entire tables or bigger strings to your step definitions.

Step Results
Each step can have one of the following results:

Success
When Cucumber finds a matching step definition it will execute it. If the block in the step definition doesn’t raise an error, the step is marked as successful (green). Anything you return from a step definition has no significance whatsoever.

Undefined
When Cucumber can’t find a matching step definition, the step gets marked as undefined (yellow), and all subsequent steps in the scenario are skipped.

Pending
When a step definition’s method invokes the pending method, the step is marked as pending (yellow, as with undefined ones), indicating that you have work to do.

Failed Steps
When a step definition’s method is executed and raises an error, the step is marked as failed (red). What you return from a step definition has no significance whatsoever.

Returning null or false will not cause a step definition to fail.

Skipped
Steps that follow undefined, pending, or failed steps are never executed, even if there is a matching step definition. These steps are marked as skipped (cyan).

Ambiguous
Step definitions have to be unique for Cucumber to know what to execute. If you use ambiguous step definitions, Cucumber will raise an AmbiguousStepDefinitionsException, telling you to fix the ambiguity.

Hooks
Hooks are blocks of code that can run at various points in the Cucumber execution cycle. They are typically used for setup and teardown of the environment before and after each scenario.

Where a hook is defined has no impact on what scenarios or steps it is run for. If you want more fine-grained control, you can use conditional hooks.

You can declare hooks in any class.

Scenario hooks
Scenario hooks run for every scenario.

Before
Before hooks run before the first step of each scenario.

Annotated method style:

@Before
public void doSomethingBefore() {
}
Lambda style:

Before(() -> {
});
Think twice before you use Before

Whatever happens in a Before hook is invisible to people who only read the features. You should consider using a background as a more explicit alternative, especially if the setup should be readable by non-technical people. Only use a Before hook for low-level logic such as starting a browser or deleting data from a database.

You can specify an explicit order for hooks if you need to.

Annotated method style:

@Before(order = 10)
public void doSomething(){
    // Do something before each scenario
}
Lambda style:

Before(10, () -> {
    // Do something before each scenario
});
After
After hooks run after the last step of each scenario, even when the step result is failed, undefined, pending, or skipped.

Annotated method style:

@After
public void doSomethingAfter(Scenario scenario){
    // Do something after after scenario
}
Lambda style:

After((Scenario scenario) -> {
});
The scenario parameter is optional. If you use it, you can inspect the status of the scenario.

For example, you can take a screenshot with WebDriver for failed scenarios and embed them in Cucumber’s report.

See the browser automation page for an example on how to do so.

Around
Cucumber-JVM does not support Around hooks.
Step hooks
Step hooks are invoked before and after a step. The hooks have ‘invoke around’ semantics, meaning that if a BeforeStep hook is executed the AfterStep hooks will also be executed regardless of the result of the step. If a step did not pass, the following step and its hooks will be skipped.

BeforeStep
Annotated method style:

@BeforeStep
public void doSomethingBeforeStep(Scenario scenario){
}
Lambda style:

BeforeStep((Scenario scenario) -> {

});
AfterStep
Annotated method style:

@AfterStep
public void doSomethingAfterStep(Scenario scenario){
}
Lambda style:

AfterStep((Scenario scenario) -> {
});
Conditional hooks
Hooks can be conditionally selected for execution based on the tags of the scenario. To run a particular hook only for certain scenarios, you can associate a Before or After hook with a tag expression.

Annotated method style:

@After("@browser and not @headless")
public void doSomethingAfter(Scenario scenario){
}
Lambda style:

After("@browser and not @headless", (Scenario scenario) -> {
});
See more documentation on tags.

Global hooks
Global hooks will run once before any scenario is run or after all scenario have been run.

BeforeAll
BeforeAll run before any scenario is run.

Annotated method style:

@BeforeAll
public static void beforeAll() {
    // Runs before all scenarios
}
AfterAll
AfterAll run after all scenarios have been executed.

Annotated method style:

@AfterAll
public static void afterAll() {
    // Runs after all scenarios
}
InstallPlugin
Cucumber-JVM does not support the InstallPlugin hook.
AfterConfiguration
AfterConfiguration has been deprecated in favor of BeforeAll and InstallPlugin depending on your needs.

Tags
Tags are a great way to organise your features and scenarios.

They can be used for two purposes:

Running a subset of scenarios
Restricting hooks to a subset of scenarios
Consider the following example:

@billing
Feature: Verify billing

  @important
  Scenario: Missing product description
    Given hello

  Scenario: Several products
    Given hello
A feature or scenario can have as many tags as you like. Separate them with spaces:

@billing @bicker @annoy
Feature: Verify billing
Tags can be placed above the following Gherkin elements:

Feature
Scenario
Scenario Outline
Examples
In Scenario Outline, you can use tags on different example like below:

Scenario Outline: Steps will run conditionally if tagged
  Given user is logged in
  When user clicks <link>
  Then user will be logged out

  @mobile
  Examples:
    | link                  |
    | logout link on mobile |

  @desktop
  Examples:
    | link                   |
    | logout link on desktop |
It is not possible to place tags above Background or steps (Given, When, Then, And and But).

Tag Inheritance
Tags are inherited by child elements.

Tags that are placed above a Feature will be inherited by Scenario, Scenario Outline, or Examples.

Tags that are placed above a Scenario Outline will be inherited by Examples.

Running a subset of scenarios
You can tell Cucumber to only run scenarios with a particular tag:

For JUnit 5 see the cucumber-junit-platform-engine documentation

For JUnit 4 and TestNG using a JVM system property:

mvn test -Dcucumber.filter.tags="@smoke and @fast"
Or an environment variable:

# Linux / OS X:
CUCUMBER_FILTER_TAGS="@smoke and @fast" mvn test

# Windows:
set CUCUMBER_FILTER_TAGS="@smoke and @fast"
mvn test
Or changing your JUnit 4/TestNG runner class:

@CucumberOptions(tags = "@smoke and @fast")
public class RunCucumberTest {}
Ignoring a subset of scenarios
You can tell Cucumber to ignore scenarios with a particular tag:

Using JUnit runner class:

@CucumberOptions(tags = "not @smoke")
public class RunCucumberTest {}
Filtering by line

Another way to run a subset of scenarios is to use the file.feature:line pattern or the --scenario option.

Tag expressions
A tag expression is an infix boolean expression. Below are some examples:

Expression	Description
@fast	Scenarios tagged with @fast
@wip and not @slow	Scenarios tagged with @wip that aren’t also tagged with @slow
@smoke and @fast	Scenarios tagged with both @smoke and @fast
@gui or @database	Scenarios tagged with either @gui or @database
For even more advanced tag expressions you can use parenthesis for clarity, or to change operator precedence:

(@smoke or @ui) and (not @slow)
Using tags for documentation
Your imagination is the only limitation when it comes to using tags for documentation.

Link to other documents
Tags can refer to IDs in external systems such as requirement management tools, issue trackers or test management tools:

@BJ-x98.77 @BJ-z12.33
Feature: Convert transaction
You can use a custom Cucumber reporting plugin that will turn tags into links pointing to documents in your external tool.

Development Process
Another creative way to use tags is to keep track of where in the development process a certain feature is:

@qa_ready
Feature: Index projects
Running Cucumber
Cucumber is a Java library with extensions for different tools and platforms. It is launched by running JUnit 4, JUnit 5, your build tool, your IDE or the CLI.

It is possible to configure how Cucumber should run features.

From the command line
The Command-Line Interface Runner (CLI Runner) is an executable Java class that can be run from the command-line.

java io.cucumber.core.cli.Main
Note that you will need to add the cucumber-core jar and all of its transitive dependencies to your classpath, in addition to the location of your compiled .class files. You can find these jars in Maven Central.

You will also need to provide the CLI with your step definitions via the --glue option followed by its package name, and the filepath of your feature file(s).

For example:

java -cp "path/to/each/jar:path/to/compiled/.class/files" io.cucumber.core.cli.Main /path/to/your/feature/files --glue hellocucumber --glue anotherpackage
Alternatively if you are using a Maven project, you can run the CLI using the Exec Maven plugin:

mvn exec:java                                  \
    -Dexec.classpathScope=test                 \
    -Dexec.mainClass=io.cucumber.core.cli.Main \
    -Dexec.args="/path/to/your/feature/files --glue hellocucumber --glue anotherpackage"
You can also run features using a build tool or an IDE.

JUnit 5
See the cucumber-junit-platform-engine documentation for more information.

JUnit 4
To use JUnit to execute cucumber scenarios add the cucumber-junit dependency to your pom.

<dependencies>
  [...]
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit</artifactId>
        <version>${cucumber.version}</version>
        <scope>test</scope>
    </dependency>
  [...]
</dependencies>
Note that cucumber-junit is based on JUnit 4. If you’re using JUnit 5, use the cucumber-junit-platform-engine or include junit-vintage-engine dependency, as well. For more information, please refer to JUnit 5 documentation

Create an empty class that uses the Cucumber JUnit runner.

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions()
public class RunCucumberTest {
}
This will execute all scenarios in same package as the runner, by default glue code is also assumed to be in the same package.

The @CucumberOptions can be used to provide additional configuration to the runner.

Using plugins:

For example if you want to tell Cucumber to use the two formatter plugins pretty and html, you can specify it like this:

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(plugin = {"pretty", "html:target/cucumber.html"})
public class RunCucumberTest {
}
For example if you want to tell Cucumber to print code snippets for missing step definitions use the summary plugin, you can specify it like this:

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(plugin = {"pretty", "summary"}, snippets = CAMELCASE)
public class RunCucumberTest {
}
The default option for snippets is UNDERSCORE. This settings can be used to specify the way code snippets will be created by Cucumber.

Performing a dry-run:

For example if you want to check whether all feature file steps have corresponding step definitions, you can specify it like this:

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(dryRun=true)
public class RunCucumberTest {
}
The default option for dryRun is false.

Formatting console output:

For example if you want console output from Cucumber in a readable format, you can specify it like this:

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(monochrome=true)
public class RunCucumberTest {
}
The default option for monochrome is false.

Select scenarios using tags:

For example if you want to tell Cucumber to only run the scenarios specified with specific tags, you can specify it like this:

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(tags = {"@foo and not @bar"})
public class RunCucumberTest {
}
Specify an object factory:

For example if you are using Cucumber with a DI framework and want to use a custom object factory, you can specify it like this:

package com.example;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(objectFactory = FooFactory.class)
public class RunCucumberTest {
}
The default option for objectFactory is to use the default object factory. Additional information about using custom object factories can be found here

There are additional options available in the @CucumberOptions annotation.

Usually, the test class will be empty. You can, however, specify several JUnit rules.

Supported JUnit annotations

Cucumber supports JUnits @ClassRule, @BeforeClass and @AfterClass annotations. These will be executed before and after all scenarios. Using them is not recommended, as it limits the portability between different runners; they may not execute correctly when using the commandline, IntelliJ IDEA or Cucumber-Eclipse . Instead, it is recommended to use Cucumbers Before and After hooks.

The Cucumber runner acts like a suite of a JUnit tests. As such other JUnit features such as Categories, Custom JUnit Listeners and Reporters can all be expected to work.

For more information on JUnit, see the JUnit website

Options
Cucumber provides several options that can be passed to on the command-line.

List configuration options
You can list the options available for the Cucumber version you are using.

Pass the --help option to print out all the available configuration options:

java io.cucumber.core.cli.Main --help
You can also use tags to specify what to run.

Cucumber will in order of precedence parse properties from system properties, environment variables and the cucumber.properties file.

Note that options provided by @CucumberOptions take precedence over the properties file and CLI arguments take precedence over all.

Note that the cucumber-junit-platform-engine is provided with properties by the Junit Platform rather than Cucumber. See junit-platform-engine Configuration Options for more information.

For example, if you are using Maven and want to run a subset of scenarios tagged with @smoke:

mvn test -Dcucumber.filter.tags="@smoke"